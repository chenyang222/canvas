<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
		
		<style type="text/css">
			#myCanvas{
				border: 1px solid #000;
				background: #ffffff;
			}
			html,body{
				padding: 0;
				margin: 0;
				background: #000000;
			}
		</style>
	</head>
	<body>
		<!--
			矩形绘制
				fillRect(x, y, width, height)
				绘制一个填充的矩形
				strokeRect(x, y, width, height)
				绘制一个矩形的边框
				clearRect(x, y, width, height)
				清除指定矩形区域，让清除部分完全透明		
				rect(x, y, width, height)
				绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。				
								
			圆形，扇形		
				arc(x, y, radius, startAngle, endAngle, anticlockwise)
				画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。
		
				arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。	
			
			路径绘制
				beginPath()
				新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。
				closePath()
				闭合路径之后图形绘制命令又重新指向到上下文中。
				stroke()
				通过线条来绘制图形轮廓。
				fill()
				通过填充路径的内容区域生成实心的图形。		
			
			移动笔触moveTo(x, y)
				将笔触移动到指定的坐标x以及y上。
				当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径。看一下下面的笑脸例子。我将用到moveTo()方法（红线处）的地方标记了。
	
			线lineTo(x, y)
				绘制一条从当前位置到指定x以及y位置的直线		
				
			线型 Line styles
				可以通过一系列属性来设置线的样式。
				
				lineWidth = value
				设置线条宽度。
				lineCap = type 属性 lineCap 的值决定了线段端点显示的样子。它可以为下面的三种的其中之一：butt，round 和 square。默认是 butt。
				设置线条末端样式。
				lineJoin = type lineJoin 的属性值决定了图形中两线段连接处所显示的样子。它可以是这三种之一：round, bevel 和 miter。默认是 miter。
				设定线条与线条间接合处的样式。
				miterLimit = value
				限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。
				getLineDash()
				返回一个包含当前虚线样式，长度为非负偶数的数组。
				setLineDash(segments)
				设置当前虚线样式。
				lineDashOffset = value
				设置虚线样式的起始偏移量。			
				
			颜色
				fillStyle = color
				设置图形的填充颜色。
				strokeStyle = color
				设置图形轮廓的颜色。		
				
			渐变 Gradients
				就好像一般的绘图软件一样，我们可以用线性或者径向的渐变来填充或描边。我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。

				createLinearGradient(x1, y1, x2, y2)
				createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。
				createRadialGradient(x1, y1, r1, x2, y2, r2)
				createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。				
				gradient.addColorStop(position, color)
				addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。	
	
			阴影 Shadows
			
				shadowOffsetX = float
				shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。
				
				shadowOffsetY = float
				shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。
				shadowBlur = float
				shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。
				shadowColor = color
				shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。
	
	
		-->
		
		<canvas id="myCanvas" width="400" height="400"></canvas>
		
		<script type="text/javascript">
			
			const myCanvas = document.getElementById('myCanvas');
			
			
			//获取上下文的渲染和绘画功能
//			let ctx = myCanvas.getContext('2d');
			//检测浏览器兼容性的方法
			if(myCanvas.getContext){
				
				const ctx = myCanvas.getContext('2d');
				
				console.log('you can use canvas');
				//绘画函数
				demo(ctx);
			}else{
				console.log('you can\nt use canvas');
			}
			
			function demo(ctx){
				
				//矩形的绘制
		        
		        ctx.fillStyle = "red"; //填充颜色

				ctx.fillRect (10, 10, 100, 100); //左上角位置x,y 以及宽高
				
				ctx.clearRect(15,15,15,15); //清除矩形区域内的内容,让清除部分完全透明
				
				ctx.strokeRect(30,30,15,15); //画出矩形的边框
				
				
				//圆形的绘制
				
				ctx.fillStyle = 'blue';
				
				ctx.arc(160,75,50,0,Math.PI*2,true);
				
				ctx.fill();
				
				
				//绘制路径
				
				ctx.beginPath();
				
				ctx.fillStyle = 'yellow';
				
				ctx.moveTo(100,200);
				
				ctx.lineTo(100,175);
				
				ctx.lineTo(150,200);
				
				ctx.fill();
				
				ctx.closePath();
		
		
				//移动笔触
			    ctx.beginPath();
			    ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
			    ctx.moveTo(110,75);
			    
			    ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
			    ctx.moveTo(65,65);
			    
			    ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
			    ctx.moveTo(95,65);
			    
			    ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
			   
			   	ctx.stroke();
			    
			    ctx.closePath();
			}
			
			
		</script>
	</body>
</html>
